import tkinter as tk
from tkinter import filedialog, Listbox, END, messagebox
import subprocess
import threading
import time
from datetime import datetime, timedelta

class FileExecutorApp:
    def __init__(self, master):
        self.master = master
        self.master.title("Executor de Arquivos com Temporizador")
        self.threads = []
        self.is_running = False

        # Frame para controles
        self.control_frame = tk.Frame(master)
        self.control_frame.pack(pady=10)

        self.start_button = tk.Button(self.control_frame, text="Iniciar", command=self.start_execution, state=tk.DISABLED)
        self.start_button.pack(side=tk.LEFT, padx=5)

        self.stop_button = tk.Button(self.control_frame, text="Parar", command=self.stop_execution, state=tk.DISABLED)
        self.stop_button.pack(side=tk.LEFT, padx=5)

        self.select_button = tk.Button(master, text="Selecionar Arquivos", command=self.select_files)
        self.select_button.pack(pady=5)

        # Lista para mostrar os arquivos e tempos
        self.listbox = Listbox(master, width=80, height=10)
        self.listbox.pack(pady=10)

        # Frame para configuração de horário
        self.time_frame = tk.Frame(master)
        self.time_frame.pack(pady=5)

        self.time_label = tk.Label(self.time_frame, text="Defina o horário (HH:MM:SS):")
        self.time_label.pack(side=tk.LEFT)

        self.time_entry = tk.Entry(self.time_frame, width=10)
        self.time_entry.pack(side=tk.LEFT)
        self.time_entry.insert(0, "00:00:00")

        self.remove_button = tk.Button(master, text="Remover Arquivo", command=self.remove_file)
        self.remove_button.pack(pady=5)

    def select_files(self):
        file_paths = filedialog.askopenfilenames(title="Selecionar Arquivos")
        if file_paths:
            for file_path in file_paths:
                self.listbox.insert(END, f"{file_path} - {self.time_entry.get()}")

            self.start_button.config(state=tk.NORMAL)  # Habilita o botão Iniciar

    def start_execution(self):
        self.is_running = True
        self.start_button.config(state=tk.DISABLED)
        self.stop_button.config(state=tk.NORMAL)

        for i in range(self.listbox.size()):
            item = self.listbox.get(i)
            file_path, time_str = item.split(" - ")
            wait_time = self.calculate_wait_time(time_str.strip())

            thread = threading.Thread(target=self.run_file_with_timer, args=(file_path, wait_time))
            self.threads.append(thread)
            thread.start()

    def calculate_wait_time(self, time_str):
        try:
            target_time = datetime.strptime(time_str, "%H:%M:%S").time()
            now = datetime.now().time()
            target_datetime = datetime.combine(datetime.now(), target_time)

            if target_datetime < datetime.now():
                target_datetime += timedelta(days=1)  # Se o horário já passou, adiciona um dia

            wait_time = (target_datetime - datetime.now()).total_seconds()
            return max(0, wait_time)  # Garante que não seja negativo
        except ValueError:
            messagebox.showerror("Erro", "Formato de hora inválido. Use HH:MM:SS.")
            return 0

    def run_file_with_timer(self, file_path, wait_time):
        time.sleep(wait_time)
        if self.is_running:
            try:
                subprocess.run(file_path, shell=True)
                print(f"Executado: {file_path}")
            except Exception as e:
                print(f"Erro ao executar {file_path}: {e}")

    def stop_execution(self):
        self.is_running = False
        self.start_button.config(state=tk.NORMAL)
        self.stop_button.config(state=tk.DISABLED)

        for thread in self.threads:
            if thread.is_alive():
                thread.join(timeout=0)

    def remove_file(self):
        selected = self.listbox.curselection()
        if selected:
            self.listbox.delete(selected)
        if self.listbox.size() == 0:
            self.start_button.config(state=tk.DISABLED)  # Desabilita o botão se não houver arquivos

# Inicializa o aplicativo
root = tk.Tk()
app = FileExecutorApp(root)
root.mainloop()
