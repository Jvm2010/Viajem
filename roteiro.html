<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Roteiro de Viagem — GPS & POIs</title>

  <!-- Tailwind (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            travel: {
              50: '#f0f9ff',
              100: '#e0f2fe',
              200: '#bae6fd',
              300: '#7dd3fc',
              400: '#38bdf8',
              500: '#0ea5e9',
              600: '#0284c7',
              700: '#0369a1',
              800: '#075985',
              900: '#0c4a6e',
            }
          }
        }
      }
    }
  </script>

  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Roboto', sans-serif; }
    #map { height: 480px; width: 100%; border-radius: 12px; }
    .place-item { transition: all .18s ease; }
    .place-item:hover { transform: translateY(-2px); box-shadow: 0 10px 15px -3px rgba(0,0,0,.06); }
    .category-badge { display:inline-block; padding:.25rem .5rem; border-radius:9999px; font-size:.75rem; font-weight:500; }
    #start-trip.tracking { animation: pulse 2s infinite; }
    @keyframes pulse { 0%{transform:scale(1)}50%{transform:scale(1.04)}100%{transform:scale(1)} }
    .toast { position:fixed; bottom:20px; right:20px; padding:12px 24px; border-radius:8px; color:white; background-color:#0ea5e9; box-shadow:0 4px 6px rgba(0,0,0,.1); z-index:10000; transition:opacity .3s ease; }
    .toast.error{ background-color:#dc2626; }
    #abort-temp { display:none; }
    .iw-btn { display:inline-block; margin-top:6px; background:#0ea5e9; color:#fff; padding:6px 10px; border-radius:6px; text-decoration:none; font-weight:600; }
    .iw-btn.desist { background:#ef4444; }
    /* estilo para o marcador ping */
    .ping-circle {
      width: 28px; height: 28px; border-radius: 50%; position: absolute; transform: translate(-50%, -50%);
      box-shadow: 0 0 0 6px rgba(14,165,233,0.15);
      animation: ping 1.2s infinite;
      pointer-events: none;
      z-index: 100000 !important;
    }
    @keyframes ping {
      0% { transform: translate(-50%, -50%) scale(1); opacity: 0.9; }
      80% { transform: translate(-50%, -50%) scale(2.6); opacity: 0; }
      100% { transform: translate(-50%, -50%) scale(2.6); opacity: 0; }
    }
    /* legenda pequena para travar/seguir */
    .follow-indicator { position: absolute; top: 88px; right: 20px; z-index: 9999; background: rgba(255,255,255,0.95); padding:6px 10px; border-radius:8px; box-shadow: 0 4px 6px rgba(0,0,0,0.08); font-weight:600; color:#0b74de; }
  </style>
</head>
<body class="bg-travel-50">

  <header class="bg-white shadow-sm sticky top-0 z-20">
    <div class="container mx-auto px-4 py-3 flex justify-between items-center">
      <h1 class="text-2xl font-bold text-travel-700">Roteiro de Viagem</h1>
      <nav class="flex gap-4">
        <a href="#" class="text-travel-600 font-medium">Fotos</a>
        <a href="#" class="text-gray-500">Sair</a>
      </nav>
    </div>
  </header>

  <main class="container mx-auto px-4 py-6 max-w-4xl">
    <!-- Configurações do Veículo -->
    <div class="card bg-white p-4 mb-6 shadow-md rounded-xl">
      <h2 class="text-lg font-semibold text-travel-800 mb-3">Configurações do Veículo</h2>
      <div class="grid grid-cols-2 gap-4">
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">Consumo (km/l)</label>
          <input id="fuel-efficiency" type="number" min="1" value="10" class="w-full p-3 border border-gray-200 rounded-lg">
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">Preço do Combustível (R$/l)</label>
          <input id="fuel-price" type="number" min="0.1" step="0.01" value="5.50" class="w-full p-3 border border-gray-200 rounded-lg">
        </div>
      </div>
    </div>

    <!-- Mapa Google -->
    <div class="card bg-white p-4 mb-6 shadow-md rounded-xl relative">
      <h2 class="text-lg font-semibold text-travel-800 mb-3">Mapa da Viagem</h2>
      <div id="map"></div>
      <div id="follow-ind" class="follow-indicator hidden">Seguindo</div>
      <div class="flex justify-between mt-3 items-center">
        <div>
          <button id="start-trip" type="button" class="bg-travel-600 text-white px-4 py-2 rounded-lg font-medium hover:bg-travel-700 transition mr-2">
            Iniciar Viagem
          </button>
          <button id="optimize-route" type="button" class="bg-travel-100 text-travel-700 px-4 py-2 rounded-lg font-medium hover:bg-travel-200 transition">
            Otimizar Rota
          </button>
          <button id="abort-temp" type="button" class="ml-2 bg-red-600 text-white px-4 py-2 rounded-lg font-medium hover:bg-red-700 transition">
            Desistir (Voltar à Rota)
          </button>
        </div>
        <div>
          <button id="clear-route" type="button" class="text-red-500 px-4 py-2 rounded-lg border border-red-200 hover:bg-red-50 transition">
            Limpar Tudo
          </button>
        </div>
      </div>
    </div>

    <!-- Adicionar Local -->
    <div class="card bg-white p-5 mb-6 shadow-md rounded-xl">
      <h2 class="text-lg font-semibold text-travel-800 mb-4">Adicionar Local</h2>
      <div class="space-y-4">
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">Pesquisar local...</label>
          <div class="relative">
            <input id="search" type="text" class="w-full p-3 border border-gray-200 rounded-lg focus:ring-2 focus:ring-travel-300 focus:border-travel-300" placeholder="Digite o nome de um local">
            <button id="btn-search" type="button" class="absolute right-2 top-2 bg-travel-500 text-white p-2 rounded-lg">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd" />
              </svg>
            </button>
          </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">Nome do Local</label>
            <input id="place-name" class="w-full p-3 border border-gray-200 rounded-lg focus:ring-2 focus:ring-travel-300">
          </div>
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">Custo (R$)</label>
            <input id="place-value" type="number" min="0" step="0.01" class="w-full p-3 border border-gray-200 rounded-lg focus:ring-2 focus:ring-travel-300">
          </div>
        </div>

        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">Categoria</label>
          <select id="place-category" class="w-full p-3 border border-gray-200 rounded-lg focus:ring-2 focus:ring-travel-300">
            <option value="attraction">Atração Turística</option>
            <option value="park">Parque/Natureza</option>
            <option value="hotel">Hotel/Hospedagem</option>
            <option value="restaurant">Restaurante</option>
            <option value="museum">Museu/Cultural</option>
            <option value="shopping">Compras</option>
            <option value="other">Outro</option>
          </select>
        </div>

        <button id="add-place" type="button" class="w-full bg-travel-600 text-white py-3 rounded-lg font-medium hover:bg-travel-700 transition">
          Adicionar Local
        </button>
      </div>
    </div>

    <!-- Locais Salvos -->
    <div class="card bg-white p-5 mb-6 shadow-md rounded-xl">
      <h2 class="text-lg font-semibold text-travel-800 mb-4">Locais Salvos</h2>
      <div id="places-list" class="space-y-3"></div>
    </div>

    <!-- Gastos Gerais -->
    <div class="card bg-white p-5 mb-6 shadow-md rounded-xl">
      <h2 class="text-lg font-semibold text-travel-800 mb-4">Gastos Gerais</h2>
      <div id="expenses-list" class="space-y-3 mb-4"></div>
      <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">Descrição</label>
          <input id="expense-title" class="w-full p-3 border border-gray-200 rounded-lg">
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">Valor (R$)</label>
          <input id="expense-amount" type="number" min="0" step="0.01" class="w-full p-3 border border-gray-200 rounded-lg">
        </div>
        <div class="flex items-end">
          <button id="add-expense" type="button" class="w-full bg-travel-600 text-white py-3 rounded-lg font-medium hover:bg-travel-700 transition">
            Adicionar
          </button>
        </div>
      </div>
    </div>

    <!-- Resumo Completo -->
    <div class="card bg-white p-5 shadow-md rounded-xl">
      <h2 class="text-lg font-semibold text-travel-800 mb-4">Resumo da Viagem</h2>
      <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
        <div class="bg-travel-50 p-3 rounded-lg">
          <p class="text-sm text-gray-600">Distância Total</p>
          <p id="total-distance" class="text-xl font-bold text-travel-700">0 km</p>
        </div>
        <div class="bg-travel-50 p-3 rounded-lg">
          <p class="text-sm text-gray-600">Tempo Total</p>
          <p id="total-time" class="text-xl font-bold text-travel-700">0 min</p>
        </div>
        <div class="bg-travel-50 p-3 rounded-lg">
          <p class="text-sm text-gray-600">Custo de Combustível</p>
          <p id="fuel-cost" class="text-xl font-bold text-travel-700">R$ 0,00</p>
        </div>
      </div>

      <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
        <div class="bg-travel-50 p-3 rounded-lg">
          <p class="text-sm text-gray-600">Custo dos Locais</p>
          <p id="places-cost" class="text-xl font-bold text-travel-700">R$ 0,00</p>
        </div>
        <div class="bg-travel-50 p-3 rounded-lg">
          <p class="text-sm text-gray-600">Gastos Gerais</p>
          <p id="expenses-cost" class="text-xl font-bold text-travel-700">R$ 0,00</p>
        </div>
        <div class="bg-travel-50 p-3 rounded-lg">
          <p class="text-sm text-gray-600">Custo Total</p>
          <p id="total-cost" class="text-xl font-bold text-travel-700">R$ 0,00</p>
        </div>
      </div>

      <div id="route-details" class="space-y-2"></div>
    </div>
  </main>

  <!-- ---------------------------
       SCRIPTS (corrigidos e extendidos)
       --------------------------- -->
  <script>
    // ---------------- CONFIG ----------------
    const GM_API_KEY = 'YOUR_API_KEY_HERE'; // substitua pela sua chave

    // Cores e ícones por categoria.
    // NOTE: troquei a cor de hotel para um tom diferente (teal) para não confundir com o azul dos pontos salvos.
    const categoryStyles = {
      attraction: { color: '#ef4444', icon: 'https://maps.google.com/mapfiles/ms/icons/red-dot.png', name: 'Atração' },
      park:       { color: '#10b981', icon: 'https://maps.google.com/mapfiles/ms/icons/green-dot.png', name: 'Parque' },
      hotel:      { color: '#06b6d4', icon: 'https://maps.google.com/mapfiles/ms/icons/ltblue-dot.png', name: 'Hotel' }, // teal / light-blue custom
      motel:      { color: '#8b5cf6', icon: 'https://maps.google.com/mapfiles/ms/icons/purple-dot.png', name: 'Motel' },
      restaurant: { color: '#f97316', icon: 'https://maps.google.com/mapfiles/ms/icons/orange-dot.png', name: 'Restaurante' },
      gas_station:{ color: '#f59e0b', icon: 'https://maps.google.com/mapfiles/ms/icons/yellow-dot.png', name: 'Posto' },
      supermarket:{ color: '#a3e635', icon: 'https://maps.google.com/mapfiles/ms/icons/lightgreen-dot.png', name: 'Mercado' },
      museum:     { color: '#f59e0b', icon: 'https://maps.google.com/mapfiles/ms/icons/yellow-dot.png', name: 'Museu' },
      shopping:   { color: '#8b5cf6', icon: 'https://maps.google.com/mapfiles/ms/icons/purple-dot.png', name: 'Compras' },
      other:      { color: '#6b7280', icon: 'https://maps.google.com/mapfiles/ms/icons/pink-dot.png', name: 'Outro' }
    };

    // ícone padrão do veículo (carro). Use um marcador que permita rotação (apenas URL com tamanho).
    // Eu usei um ícone simples. Você pode trocar por um SVG mais bonito.
    const vehicleIconBase = {
      url: 'https://maps.google.com/mapfiles/kml/shapes/cabs.png', // ícone de carro genérico
      scaledSize: new google.maps.Size ? new google.maps.Size(36, 36) : undefined,
      anchor: new google.maps.Point ? new google.maps.Point(18, 18) : undefined
    };

    // ícones personalizados para locais salvos (azul claro)
    const savedPlaceIconUrl = 'data:image/svg+xml;utf8,' + encodeURIComponent(`
      <svg xmlns="http://www.w3.org/2000/svg" width="36" height="36" viewBox="0 0 24 24">
        <circle cx="12" cy="10" r="6" fill="#7dd3fc" stroke="#0ea5e9" stroke-width="1.5"/>
        <path d="M12 16c-3 0-5 1.5-5 3v1h10v-1c0-1.5-2-3-5-3z" fill="#60a5fa"/>
      </svg>
    `);

    // ícone para ping temporário (azul claro)
    const pingMarkerIconUrl = 'data:image/svg+xml;utf8,' + encodeURIComponent(`
      <svg xmlns="http://www.w3.org/2000/svg" width="44" height="44" viewBox="0 0 24 24">
        <circle cx="12" cy="12" r="6" fill="#bae6fd" stroke="#0ea5e9" stroke-width="1.4"/>
      </svg>
    `);

    // utils (corrigidas)
    function showToast(message, isError = false, time = 3000) {
      const toast = document.createElement('div');
      toast.className = 'toast' + (isError ? ' error' : '');
      toast.textContent = message;
      document.body.appendChild(toast);
      setTimeout(() => { toast.style.opacity = '0'; setTimeout(()=>toast.remove(),300); }, time);
    }

    function formatCurrency(value) {
      if (!value && value !== 0) return 'R$ 0,00';
      const n = Number(value) || 0;
      return n.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
    }

    function hexToRgba(hex, alpha=1) {
      try {
        if (!hex) return `rgba(0,0,0,${alpha})`;
        const h = hex.replace('#', '');
        const bigint = parseInt(h, 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = (bigint) & 255;
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      } catch (e) {
        return `rgba(0,0,0,${alpha})`;
      }
    }

    // distância haversine (metros)
    function distanceMeters(a, b) {
      const R = 6371000;
      const toRad = d => d * Math.PI / 180;
      const dLat = toRad(b.lat - a.lat);
      const dLon = toRad(b.lng - a.lng);
      const lat1 = toRad(a.lat);
      const lat2 = toRad(b.lat);
      const hav = Math.sin(dLat/2)*Math.sin(dLat/2) + Math.sin(dLon/2)*Math.sin(dLon/2)*Math.cos(lat1)*Math.cos(lat2);
      const c = 2 * Math.atan2(Math.sqrt(hav), Math.sqrt(1-hav));
      return R * c;
    }

    // heading entre dois pts (graus)
    function computeHeading(a, b) {
      const toRad = deg => deg * Math.PI / 180;
      const toDeg = rad => rad * 180 / Math.PI;
      const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
      const dLon = toRad(b.lng - a.lng);
      const y = Math.sin(dLon) * Math.cos(lat2);
      const x = Math.cos(lat1)*Math.sin(lat2) - Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);
      return (toDeg(Math.atan2(y,x)) + 360) % 360;
    }

    // ===== estado global =====
    let map, directionsService, directionsRendererMain, directionsRendererTemp, placesService, infoWindow;
    let markers = [], poiMarkers = [], savedPlaceMarkers = [];
    let places = [], generalExpenses = [];
    let lastRouteResult = null;          // rota principal (original)
    let lastRouteResultSaved = null;     // cópia do original para reverter se necessário
    let watchId = null;                  // geolocation watch id
    let currentPositionMarker = null;
    let pathCoordinates = [];            // caminho percorrido (linha azul)
    let pathPolyline = null;
    let tempDestination = null;          // POI temporário selecionado (objeto place)
    let currentPositionIcon = null;
    let poiDebounceTimer = null;
    let lastPOICenter = null;            // evitar buscas repetidas muito próximas
    let POI_SEARCH_DISTANCE_THRESHOLD = 500; // metros
    let followMode = true;               // pan map to user while tracking
    let savedRouteZoomPadding = 120;
    let smoothPathBuffer = [];           // buffer para suavização
    const SMOOTH_BUFFER_MAX = 6;         // quantos pontos usar para média
    const GPS_MIN_MOVEMENT = 4;          // metros mínimo para adicionar breadcrumb (evita jitter)

    // marcador temporário de busca (ping) quando o usuário busca um local.
    let searchTempMarker = null;
    let searchTempPingDiv = null; // DOM ping overlay

    // ---------- initMap (callback) ----------
    function initMap() {
      const initialLocation = { lat: -15.795, lng: -47.891 }; // Brasília por padrão

      map = new google.maps.Map(document.getElementById('map'), {
        center: initialLocation,
        zoom: 13,
        mapTypeControl: true,
        streetViewControl: false,
        gestureHandling: 'greedy',
        styles: [{ featureType: "poi", elementType: "labels", stylers: [{ visibility: "off" }] }]
      });

      directionsService = new google.maps.DirectionsService();
      // ROTA PRINCIPAL: cor azul (visível)
      directionsRendererMain = new google.maps.DirectionsRenderer({
        map: map,
        suppressMarkers: true,
        polylineOptions: { strokeColor: '#0ea5e9', strokeOpacity: 0.95, strokeWeight: 6 } // cor ajustada
      });
      // ROTA TEMP: cor verde
      directionsRendererTemp = new google.maps.DirectionsRenderer({
        map: map,
        suppressMarkers: true,
        polylineOptions: { strokeColor: '#16a34a', strokeOpacity: 0.95, strokeWeight: 6 }
      });

      infoWindow = new google.maps.InfoWindow();

      currentPositionIcon = {
        url: 'https://maps.google.com/mapfiles/ms/icons/blue-dot.png',
        scaledSize: new google.maps.Size(32, 32),
        anchor: new google.maps.Point(16, 16)
      };

      placesService = new google.maps.places.PlacesService(map);

      // polyline do caminho percorrido (GPS breadcrumb) - cor mais viva
      pathPolyline = new google.maps.Polyline({
        path: pathCoordinates,
        geodesic: true,
        strokeColor: '#0b74de', // caminho percorrido cor azul vivo
        strokeOpacity: 1.0,
        strokeWeight: 4,
        map
      });

      // listeners e dados
      loadData();
      setupEventListeners();

      // buscar POIs sempre que o centro do mapa mudar (debounce)
      map.addListener('idle', () => { schedulePOISearch(map.getCenter()); });

      // clique no mapa fecha infoWindow e limpa searchTempMarker se existir
      map.addListener('click', () => {
        infoWindow.close();
        // se houver marker de busca temporária, permite salvá-lo manualmente
      });

      console.log('Mapa inicializado.');
    }

    // ---------- GPS Tracking (melhorado) ----------
    // comportamento:
    // - usa watchPosition (enableHighAccuracy)
    // - filtra jitter: só adiciona ponto se distância > GPS_MIN_MOVEMENT
    // - calcula heading e gira o ícone do carro
    // - atualiza polyline suavemente (média móvel curta)
    function startGPSTracking() {
      if (!navigator.geolocation) { showToast('Geolocalização não suportada', true); return; }
      showToast('Iniciando rastreamento GPS...');
      // limpar buffers
      smoothPathBuffer = [];
      pathCoordinates = [];
      if (pathPolyline) pathPolyline.setPath(pathCoordinates);

      const success = pos => {
        try {
          const lat = pos.coords.latitude, lng = pos.coords.longitude;
          const p = { lat, lng, timestamp: pos.timestamp || Date.now() };

          // se não houver marcador atual, cria um com ícone rotacionável
          if (!currentPositionMarker) {
            currentPositionMarker = new google.maps.Marker({
              position: p,
              map,
              icon: Object.assign({}, vehicleIconBase),
              title: 'Sua posição atual',
              zIndex: 1000
            });
          } else {
            currentPositionMarker.setPosition(p);
          }

          // suavização simples: push em buffer e calc média para plot
          smoothPathBuffer.push(p);
          if (smoothPathBuffer.length > SMOOTH_BUFFER_MAX) smoothPathBuffer.shift();
          const averaged = averageLatLngs(smoothPathBuffer);

          // only push to path if moved sufficiently from last pushed point
          const last = pathCoordinates.length ? pathCoordinates[pathCoordinates.length - 1] : null;
          if (!last || distanceMeters(last, averaged) >= GPS_MIN_MOVEMENT) {
            pathCoordinates.push(averaged);
            if (pathPolyline) pathPolyline.setPath(pathCoordinates);
          }

          // compute heading (if possible)
          if (pathCoordinates.length >= 2) {
            const a = pathCoordinates[pathCoordinates.length - 2];
            const b = pathCoordinates[pathCoordinates.length - 1];
            const heading = computeHeading(a, b);
            rotateMarkerIcon(currentPositionMarker, heading);
          }

          // pan / follow
          followUser(averaged);

          // buscar POIs automaticamente (se necessário)
          schedulePOISearch(new google.maps.LatLng(averaged.lat, averaged.lng));

          // se há rota temporária, recalcular a rota temporária a partir da posição atual
          if (tempDestination) computeTempRoute(averaged, tempDestination);
          else updateMainRouteFromCurrentPosition(averaged);
        } catch (e) {
          console.warn('startGPSTracking success handler error', e);
        }
      };

      const error = err => {
        console.warn('GPS error', err);
        let msg = 'Erro desconhecido no GPS.';
        if (err && err.code !== undefined) {
          if (err.code === 1) msg = 'Permissão de localização negada.';
          else if (err.code === 2) msg = 'Informação de localização indisponível.';
          else if (err.code === 3) msg = 'Tempo de espera para localização expirado.';
        }
        showToast(msg, true);
        stopGPSTracking();
      };

      watchId = navigator.geolocation.watchPosition(success, error, { enableHighAccuracy: true, maximumAge: 1000, timeout: 30000 });

      const startBtn = document.getElementById('start-trip');
      startBtn.textContent = 'Parar Rastreamento';
      startBtn.classList.remove('bg-travel-600');
      startBtn.classList.add('bg-red-600', 'tracking');
      document.getElementById('follow-ind').classList.remove('hidden');
      followMode = true;
    }

    function stopGPSTracking() {
      if (watchId) { navigator.geolocation.clearWatch(watchId); watchId = null; }
      const startBtn = document.getElementById('start-trip');
      startBtn.textContent = 'Iniciar Viagem';
      startBtn.classList.add('bg-travel-600');
      startBtn.classList.remove('bg-red-600', 'tracking');
      document.getElementById('follow-ind').classList.add('hidden');
    }

    function rotateMarkerIcon(marker, heading) {
      // tenta rotacionar o ícone do marcador usando SVG transform se o ícone for SVG DataURI
      // fallback: muda ícone para um marcador rotacionado se necessário (omito por simplicidade)
      try {
        if (!marker) return;
        const icon = marker.getIcon();
        // se for um objeto com url, criamos uma versão CSS transform via canvas não trivial. Simples approach: setLabel com unicode arrow (opcional)
        // aqui apenas tentamos girar se icon.path existe (Vector icon), caso contrário ignoramos
        marker.setIcon(Object.assign({}, icon)); // no-op para manter consistência
        // podemos colocar rotation as property para uso futuro
        marker.rotation = heading;
      } catch (e) { /* ignore */ }
    }

    function followUser(pos) {
      try {
        if (!pos) return;
        // centralizar suavemente
        if (followMode) {
          map.panTo(new google.maps.LatLng(pos.lat, pos.lng));
          if (map.getZoom() < 15) map.setZoom(15);
        }
      } catch(e) { console.warn('followUser error', e); }
    }

    // média simples de latitude/longitude do buffer
    function averageLatLngs(arr) {
      if (!arr || arr.length === 0) return null;
      let sumLat = 0, sumLng = 0;
      arr.forEach(p => { sumLat += p.lat; sumLng += p.lng; });
      return { lat: sumLat / arr.length, lng: sumLng / arr.length };
    }

    // recalcula a rota principal usando a posição atual como origem (preserva waypoints/destino)
    function updateMainRouteFromCurrentPosition(currentPos) {
      if (!places || places.length < 2) return;
      const waypoints = places.slice(1, -1).map(p => ({ location: { lat: p.lat, lng: p.lng }, stopover: true }));
      const request = {
        origin: { lat: currentPos.lat, lng: currentPos.lng },
        destination: { lat: places[places.length -1].lat, lng: places[places.length -1].lng },
        waypoints,
        travelMode: google.maps.TravelMode.DRIVING,
        optimizeWaypoints: true,
        provideRouteAlternatives: false
      };
      directionsService.route(request, (result, status) => {
        if (status === 'OK') {
          directionsRendererMain.setMap(map);
          directionsRendererMain.setDirections(result);
          lastRouteResult = result;
          renderRouteDetails(result);
          updateStats();
        } else {
          // log warning mas não enche o usuário com toasts
          console.warn('updateMainRouteFromCurrentPosition status', status);
        }
      });
    }

    // ---------- Persistência ----------
    function loadData() {
      try {
        const savedPlaces = localStorage.getItem('travel_places');
        const savedExpenses = localStorage.getItem('travel_expenses');
        if (savedPlaces) places = JSON.parse(savedPlaces);
        if (savedExpenses) generalExpenses = JSON.parse(savedExpenses);
      } catch (err) { console.warn('Erro parse localStorage', err); places = []; generalExpenses = []; }
      renderPlaces();
      renderExpenses();
      updateRoute(); // tenta renderizar rota se houver places
    }

    function saveData() {
      try {
        localStorage.setItem('travel_places', JSON.stringify(places));
        localStorage.setItem('travel_expenses', JSON.stringify(generalExpenses));
      } catch (err) { console.warn('Erro ao salvar localStorage', err); }
    }

    // ---------- Renderização listas ----------
    function renderPlaces() {
      const container = document.getElementById('places-list'); container.innerHTML = '';
      if (!places || places.length === 0) {
        container.innerHTML = '<div class="text-center py-4 text-gray-500">Nenhum local adicionado ainda</div>';
        updateStats(); return;
      }
      places.forEach((place, index) => {
        const category = categoryStyles[place.category] || categoryStyles.other;
        // badgeBg com alfa
        const badgeBg = hexToRgba(category.color, .12);
        const div = document.createElement('div');
        div.className = 'place-item bg-white p-4 rounded-lg border border-gray-200 flex justify-between items-start';
        // construir innerHTML com template strings (correto)
        div.innerHTML = `
          <div>
            <div class="flex items-center gap-2">
              <h3 class="font-semibold text-travel-800">${escapeHtml(place.name)}</h3>
              <span class="category-badge" style="background-color: ${badgeBg}; color: ${category.color};">${category.name}</span>
            </div>
            ${place.value ? `<p class="text-sm text-travel-600">${formatCurrency(place.value)}</p>` : ''}
            ${place.address ? `<p class="text-xs text-gray-500 mt-1">${escapeHtml(place.address)}</p>` : ''}
          </div>
          <div class="flex gap-2 items-center">
            <button data-index="${index}" title="Subir" class="move-up text-travel-600 hover:text-travel-800 p-1">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M10 3l5 6H5l5-6z"/></svg>
            </button>
            <button data-index="${index}" title="Descer" class="move-down text-travel-600 hover:text-travel-800 p-1">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M10 17l-5-6h10l-5 6z"/></svg>
            </button>
            <button data-index="${index}" title="Remover" class="delete-place text-red-500 hover:text-red-700 p-1">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"/></svg>
            </button>
          </div>
        `;
        container.appendChild(div);
      });
      updateStats();
      // sincronizar marcadores de locais salvos
      refreshSavedPlaceMarkers();
    }

    function renderExpenses() {
      const container = document.getElementById('expenses-list'); container.innerHTML = '';
      if (!generalExpenses || generalExpenses.length === 0) {
        container.innerHTML = '<div class="text-center py-4 text-gray-500">Nenhum gasto geral adicionado</div>'; updateStats(); return;
      }
      generalExpenses.forEach((expense, index) => {
        const dateStr = expense.date ? new Date(expense.date).toLocaleDateString() : '';
        const div = document.createElement('div');
        div.className = 'flex justify-between items-center bg-gray-50 p-3 rounded-lg';
        div.innerHTML = `
          <div>
            <p class="font-medium">${escapeHtml(expense.title)}</p>
            <p class="text-xs text-gray-500">${escapeHtml(dateStr)}</p>
          </div>
          <div class="flex items-center gap-2">
            <p class="font-medium">${formatCurrency(expense.amount)}</p>
            <button data-index="${index}" class="delete-expense text-red-500 hover:text-red-700" title="Remover">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"/></svg>
            </button>
          </div>
        `;
        container.appendChild(div);
      });
      updateStats();
    }

    // segurança ao injetar texto em innerHTML
    function escapeHtml(s) {
      if (!s && s !== 0) return '';
      return String(s).replace(/[&<>"'`=\/]/g, function (c) {
        return {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;',
          '/': '&#x2F;',
          '`': '&#x60;',
          '=': '&#x3D;'
        }[c];
      });
    }

    // ---------- Rota (marcadores + directions) ----------
    function clearMarkers(arr) {
      if (!arr || !arr.forEach) return;
      arr.forEach(m => { try { m.setMap(null); } catch(e) {} });
      arr.length = 0;
    }

    function refreshSavedPlaceMarkers() {
      // remove antigos
      clearMarkers(savedPlaceMarkers);
      // recria
      places.forEach((place, index) => {
        const category = categoryStyles[place.category] || categoryStyles.other;
        const icon = {
          url: savedPlaceIconUrl,
          scaledSize: new google.maps.Size(36, 36),
          labelOrigin: new google.maps.Point(18, 10)
        };
        const marker = new google.maps.Marker({
          position: { lat: place.lat, lng: place.lng },
          map,
          label: { text: String(index+1), color: '#044f8b', fontSize: '12px', fontWeight: '600' },
          icon,
          zIndex: 800
        });
        marker.addListener('click', () => {
          const html = `
            <div style="max-width:220px">
              <h3 style="margin:0 0 4px 0;font-weight:700">${escapeHtml(place.name)}</h3>
              <div style="color:${category.color};font-weight:600;margin-bottom:6px">${category.name}</div>
              ${place.value ? `<div style="margin-bottom:6px">${formatCurrency(place.value)}</div>` : ''}
              ${place.address ? `<div style="font-size:12px;color:#6b7280">${escapeHtml(place.address)}</div>` : ''}
            </div>
          `;
          infoWindow.setContent(html);
          infoWindow.open(map, marker);
        });
        savedPlaceMarkers.push(marker);
      });
    }

    function updateRoute() {
      // limpa marcadores secundários
      clearMarkers(markers);
      // se sem places, limpa rota
      if (!places || places.length === 0) {
        directionsRendererMain.setMap(null);
        directionsRendererMain.setDirections({ routes: [] });
        lastRouteResult = null; lastRouteResultSaved = null;
        document.getElementById('route-details').innerHTML = '';
        updateStats();
        refreshSavedPlaceMarkers();
        return;
      }

      // posicionado marcadores dos locais (mas já temos savedPlaceMarkers)
      refreshSavedPlaceMarkers();

      if (places.length === 1) {
        map.setCenter({ lat: places[0].lat, lng: places[0].lng });
        map.setZoom(14);
        directionsRendererMain.setMap(null);
        directionsRendererMain.setDirections({ routes: [] });
        lastRouteResult = null; lastRouteResultSaved = null;
        document.getElementById('route-details').innerHTML = '';
        updateStats();
        return;
      }

      if (places.length >= 2) {
        const waypoints = places.slice(1, -1).map(p => ({ location: { lat: p.lat, lng: p.lng }, stopover: true }));
        const request = {
          origin: { lat: places[0].lat, lng: places[0].lng },
          destination: { lat: places[places.length -1].lat, lng: places[places.length -1].lng },
          waypoints, travelMode: google.maps.TravelMode.DRIVING, optimizeWaypoints: true, provideRouteAlternatives: false
        };
        directionsService.route(request, (result, status) => {
          if (status === 'OK') {
            directionsRendererMain.setMap(map);
            directionsRendererMain.setDirections(result);
            lastRouteResult = result;
            // salvar cópia para reverter caso use rota temporária
            try { lastRouteResultSaved = JSON.parse(JSON.stringify(result)); } catch(e){ lastRouteResultSaved = null; }
            try {
              const bounds = new google.maps.LatLngBounds();
              result.routes[0].legs.forEach(leg => { bounds.extend(leg.start_location); bounds.extend(leg.end_location); });
              map.fitBounds(bounds, savedRouteZoomPadding);
            } catch (err) { console.warn('bounds error', err); }
            renderRouteDetails(result);
            updateStats();
          } else {
            showToast('Erro ao calcular rota: ' + status, true);
            lastRouteResult = null;
            updateStats();
          }
        });
      }
    }

    function renderRouteDetails(routeResult) {
      const container = document.getElementById('route-details'); container.innerHTML = '<h3 class="font-semibold mb-2">Detalhes do Percurso:</h3>';
      if (!routeResult || !routeResult.routes || !routeResult.routes[0]) {
        container.innerHTML += '<div class="text-gray-500">Sem detalhes de rota.</div>'; return;
      }
      const legs = routeResult.routes[0].legs || [];
      legs.forEach((leg,index) => {
        const fromPlace = places[index] || { name: 'Ponto' }, toPlace = places[index+1] || { name: 'Destino' };
        const div = document.createElement('div');
        div.className = 'bg-gray-50 p-3 rounded-lg mb-2';
        div.innerHTML = `
          <div class="flex justify-between items-center">
            <div>
              <p class="font-medium">${escapeHtml(fromPlace.name)} → ${escapeHtml(toPlace.name)}</p>
              <p class="text-sm text-gray-600">${escapeHtml(leg.distance.text)} • ${escapeHtml(leg.duration.text)}</p>
            </div>
            <p class="text-travel-700 font-medium">${escapeHtml(leg.duration.text)}</p>
          </div>
        `;
        container.appendChild(div);
      });
    }

    // ---------- Estatísticas ----------
    function updateStats() {
      const placesCost = (places||[]).reduce((s,p)=>s+(parseFloat(p.value)||0),0);
      document.getElementById('places-cost').textContent = formatCurrency(placesCost);
      const expensesCost = (generalExpenses||[]).reduce((s,e)=>s+(parseFloat(e.amount)||0),0);
      document.getElementById('expenses-cost').textContent = formatCurrency(expensesCost);

      let totalDistance=0, totalTime=0, fuelCost=0;
      if (lastRouteResult && lastRouteResult.routes && lastRouteResult.routes[0]) {
        lastRouteResult.routes[0].legs.forEach(leg=>{ totalDistance += (leg.distance && leg.distance.value)?leg.distance.value:0; totalTime += (leg.duration && leg.duration.value)?leg.duration.value:0; });
        const fuelEfficiency = parseFloat(document.getElementById('fuel-efficiency').value) || 10;
        const fuelPrice = parseFloat(document.getElementById('fuel-price').value) || 5.50;
        const fuelConsumption = (totalDistance/1000)/fuelEfficiency;
        fuelCost = fuelConsumption * fuelPrice;
      }

      document.getElementById('total-distance').textContent = `${(totalDistance/1000).toFixed(1)} km`;
      const hours = Math.floor(totalTime/3600); const minutes = Math.round((totalTime%3600)/60);
      let timeText = ''; if(hours>0) timeText += `${hours} h `; timeText += `${minutes} min`;
      document.getElementById('total-time').textContent = timeText;
      document.getElementById('fuel-cost').textContent = formatCurrency(parseFloat(fuelCost)||0);
      const totalCost = placesCost + expensesCost + (fuelCost||0);
      document.getElementById('total-cost').textContent = formatCurrency(totalCost);
    }

    // ---------- POIs (auto search) ----------
    function schedulePOISearch(centerLatLng) {
      if (poiDebounceTimer) clearTimeout(poiDebounceTimer);
      poiDebounceTimer = setTimeout(() => {
        if (lastPOICenter) {
          const last = lastPOICenter;
          const dist = google.maps.geometry.spherical.computeDistanceBetween(new google.maps.LatLng(last.lat,last.lng), centerLatLng);
          if (dist < POI_SEARCH_DISTANCE_THRESHOLD) return;
        }
        searchNearbyPOIs(centerLatLng);
      }, 800);
    }

    function searchNearbyPOIs(center) {
      if (!map || !placesService) { /* console.warn('Serviço de lugares não disponível.'); */ return; }
      const centerLatLng = center instanceof google.maps.LatLng ? center : new google.maps.LatLng(center.lat, center.lng);
      lastPOICenter = { lat: centerLatLng.lat(), lng: centerLatLng.lng() };

      // limpar POI markers antigos
      poiMarkers.forEach(m => m.setMap(null)); poiMarkers = [];

      const typesToSearch = ['gas_station','lodging','restaurant','supermarket','convenience_store','tourist_attraction'];
      const radius = 3000; // 3 km por padrão (mais responsivo)

      typesToSearch.forEach(type => {
        const req = { location: centerLatLng, radius, type };
        placesService.nearbySearch(req, (results, status) => {
          if (status === google.maps.places.PlacesServiceStatus.OK && results && results.length) {
            results.slice(0, 12).forEach(r => addPOIMarker(r, type));
          } else {
            // console.warn('POI search', type, status);
          }
        });
      });
    }

    function addPOIMarker(placeResult, forcedType) {
      if (!placeResult.geometry || !placeResult.geometry.location) return;
      let type = forcedType || (placeResult.types && placeResult.types[0]) || 'other';
      if (type.includes('lodging')) type = 'hotel';
      if (type.includes('gas')) type = 'gas_station';
      if (type.includes('restaurant')) type = 'restaurant';
      if (type.includes('tourist')) type = 'attraction';
      if (type.includes('supermarket') || type.includes('grocery')) type = 'supermarket';
      if (type.includes('convenience')) type = 'supermarket';

      const style = categoryStyles[type] || categoryStyles.other;
      const icon = { url: style.icon, scaledSize: new google.maps.Size(36,36) };

      const marker = new google.maps.Marker({
        position: placeResult.geometry.location,
        map,
        title: placeResult.name,
        icon,
        zIndex: 900
      });

      marker.addListener('click', () => {
        const content = document.createElement('div');
        content.style.maxWidth = '260px';
        content.innerHTML = `
          <div style="max-width:260px">
            <h3 style="margin:0 0 6px 0;font-weight:700">${escapeHtml(placeResult.name)}</h3>
            <div style="color:${style.color};font-weight:600;margin-bottom:6px">${style.name}</div>
            ${placeResult.vicinity ? `<div style="font-size:12px;color:#6b7280">${escapeHtml(placeResult.vicinity)}</div>` : ''}
            <div style="margin-top:8px; display:flex; gap:8px">
              <a href="#" data-place-id="${placeResult.place_id}" class="iw-btn go-btn">Ir até aqui</a>
              <a href="#" data-place-id="${placeResult.place_id}" class="iw-btn save-btn" style="background:#60a5fa">Salvar</a>
            </div>
          </div>
        `;
        infoWindow.setContent(content);
        infoWindow.open(map, marker);

        google.maps.event.addListenerOnce(infoWindow, 'domready', () => {
          const goBtn = document.querySelector('.iw-btn.go-btn');
          if (goBtn) {
            goBtn.addEventListener('click', (ev) => {
              ev.preventDefault();
              const poi = {
                name: placeResult.name,
                lat: placeResult.geometry.location.lat(),
                lng: placeResult.geometry.location.lng(),
                address: placeResult.vicinity || '',
                place_id: placeResult.place_id,
                category: type
              };
              setTemporaryDestination(poi);
              infoWindow.close();
            });
          }
          const saveBtn = document.querySelector('.iw-btn.save-btn');
          if (saveBtn) {
            saveBtn.addEventListener('click', (ev) => {
              ev.preventDefault();
              // salva o local exatamente onde o marcador do POI está
              const p = {
                name: placeResult.name,
                lat: placeResult.geometry.location.lat(),
                lng: placeResult.geometry.location.lng(),
                address: placeResult.vicinity || '',
                value: 0,
                category: type,
                date: new Date().toISOString()
              };
              places.push(p); saveData(); renderPlaces(); updateRoute(); showToast('Local salvo com sucesso!');
              infoWindow.close();
            });
          }
        });
      });

      poiMarkers.push(marker);
    }

    // ---------- Busca pelo campo "Pesquisar" — cria ping e marcador arrastável para salvar posição exata ----------
    function searchPlaceQuery(query) {
      if (!query || !placesService || !map) { showToast('Serviço de pesquisa indisponível', true); return; }
      // limpar marker temporário anterior
      if (searchTempMarker) { searchTempMarker.setMap(null); searchTempMarker = null; }
      // usar findPlaceFromQuery para obter resultados
      const svc = new google.maps.places.PlacesService(map);
      svc.findPlaceFromQuery({ query, fields: ['name','geometry','formatted_address','place_id','types'] }, (results, status) => {
        if (status === google.maps.places.PlacesServiceStatus.OK && results && results[0]) {
          const p = results[0];
          const loc = p.geometry.location;
          // center e zoom
          map.setCenter(loc);
          map.setZoom(16);
          // criar marker temporário azul claro, arrastável, com ping visual
          searchTempMarker = new google.maps.Marker({
            map,
            position: loc,
            title: p.name,
            icon: {
              url: pingMarkerIconUrl,
              scaledSize: new google.maps.Size(42, 42),
              anchor: new google.maps.Point(21, 21)
            },
            draggable: true,
            zIndex: 1001
          });
          // criar ping DOM (posição absoluta sobre o mapa)
          createPingOverlayAt(loc);

          // infoWindow com opção "Salvar aqui" que salva a posição atual do marker (arrastável)
          const content = document.createElement('div');
          content.style.maxWidth = '280px';
          content.innerHTML = `
            <div>
              <h3 style="margin:0 0 6px 0;font-weight:700">${escapeHtml(p.name)}</h3>
              <div style="font-size:12px;color:#6b7280;margin-bottom:8px">${escapeHtml(p.formatted_address || '')}</div>
              <div style="display:flex; gap:8px;">
                <a href="#" class="iw-btn save-exact">Salvar neste local</a>
                <a href="#" class="iw-btn desist" style="background:#ef4444">Cancelar</a>
              </div>
              <div style="font-size:12px;color:#6b7280;margin-top:6px">Arraste o marcador para ajustar a posição exata antes de salvar.</div>
            </div>
          `;
          infoWindow.setContent(content);
          infoWindow.open(map, searchTempMarker);

          // listeners no infoWindow DOM
          google.maps.event.addListenerOnce(infoWindow, 'domready', () => {
            const saveBtn = document.querySelector('.iw-btn.save-exact');
            const cancelBtn = document.querySelector('.iw-btn.desist');
            if (saveBtn) {
              saveBtn.addEventListener('click', (ev) => {
                ev.preventDefault();
                const pos = searchTempMarker.getPosition();
                const newPlace = {
                  name: p.name || document.getElementById('place-name').value || 'Local',
                  value: parseFloat(document.getElementById('place-value').value) || 0,
                  category: document.getElementById('place-category').value || (p.types && p.types.includes('lodging') ? 'hotel' : 'other'),
                  lat: pos.lat(),
                  lng: pos.lng(),
                  address: p.formatted_address || p.name || '',
                  date: new Date().toISOString()
                };
                places.push(newPlace);
                saveData(); renderPlaces(); updateRoute();
                showToast('Local salvo com sucesso!');
                // remover ping/marker
                if (searchTempMarker) { searchTempMarker.setMap(null); searchTempMarker = null; }
                removePingOverlay();
                infoWindow.close();
              });
            }
            if (cancelBtn) {
              cancelBtn.addEventListener('click', (ev) => {
                ev.preventDefault();
                if (searchTempMarker) { searchTempMarker.setMap(null); searchTempMarker = null; }
                removePingOverlay();
                infoWindow.close();
                showToast('Pesquisa cancelada');
              });
            }
          });

          // se o usuário arrastar o marker, atualiza o ping overlay posição
          searchTempMarker.addListener('drag', () => {
            updatePingOverlayPosition(searchTempMarker.getPosition());
          });
          searchTempMarker.addListener('dragend', () => {
            updatePingOverlayPosition(searchTempMarker.getPosition());
          });

          // preenche inputs para conveniência
          document.getElementById('place-name').value = p.name || '';
          document.getElementById('search').value = p.formatted_address || p.name || '';
          // atribui categoria sugerida
          let category = 'other';
          if (p.types && (p.types.includes('park') || p.types.includes('natural_feature'))) category = 'park';
          else if (p.types && (p.types.includes('tourist_attraction') || p.types.includes('point_of_interest'))) category = 'attraction';
          else if (p.types && (p.types.includes('lodging') || p.types.includes('hotel'))) category = 'hotel';
          else if (p.types && (p.types.includes('restaurant') || p.types.includes('food'))) category = 'restaurant';
          else if (p.types && (p.types.includes('museum') || p.types.includes('art_gallery'))) category = 'museum';
          else if (p.types && (p.types.includes('shopping_mall') || p.types.includes('store'))) category = 'shopping';
          document.getElementById('place-category').value = category;
          showToast('Local encontrado — ajuste o marcador e clique em "Salvar neste local".');
        } else {
          showToast('Local não encontrado. Tente outro termo de busca.', true);
        }
      });
    }

    // cria overlay DOM para ping (visual)
    function createPingOverlayAt(latLng) {
      removePingOverlay();
      const projection = map.getProjection ? map.getProjection() : null;
      // usamos um overlay simples que posiciona uma div na tela usando fromLatLngToDivPixel quando domready
      const overlay = new google.maps.OverlayView();
      overlay.onAdd = function() {
        const layer = document.createElement('div');
        layer.style.position = 'absolute';
        layer.className = 'ping-overlay';
        layer.innerHTML = `<div class="ping-circle"></div>`;
        this.div = layer;
        const panes = this.getPanes();
        panes.overlayMouseTarget.appendChild(layer);
      };
      overlay.draw = function() {
        if (!this.div) return;
        const point = this.getProjection().fromLatLngToDivPixel(latLng);
        this.div.style.left = (point.x) + 'px';
        this.div.style.top = (point.y) + 'px';
      };
      overlay.onRemove = function() {
        if (this.div && this.div.parentNode) this.div.parentNode.removeChild(this.div);
        this.div = null;
      };
      overlay.setMap(map);
      searchTempPingDiv = overlay;
    }

    function updatePingOverlayPosition(latLng) {
      try {
        if (searchTempPingDiv && searchTempMarker) {
          searchTempPingDiv.draw();
        } else if (searchTempMarker) {
          // recreate to ensure position update
          createPingOverlayAt(searchTempMarker.getPosition());
        }
      } catch (e) {
        // ignore
      }
    }

    function removePingOverlay() {
      if (searchTempPingDiv) {
        try { searchTempPingDiv.setMap(null); } catch(e) {}
        searchTempPingDiv = null;
      }
    }

    // ---------- Rota Temporária (Ir até aqui) ----------
    function setTemporaryDestination(poi) {
      tempDestination = poi;
      document.getElementById('abort-temp').style.display = 'inline-block';
      showToast(`Rota temporária definida para ${poi.name}`);
      const start = currentPositionMarker ? currentPositionMarker.getPosition() : map.getCenter();
      if (!start) { showToast('Posição inicial desconhecida para ir até aqui.', true); return; }
      const startLatLng = { lat: start.lat(), lng: start.lng() };
      computeTempRoute(startLatLng, poi);
    }

    function computeTempRoute(startLatLng, poi) {
      if (!poi) return;
      const request = {
        origin: startLatLng,
        destination: { lat: poi.lat, lng: poi.lng },
        travelMode: google.maps.TravelMode.DRIVING,
        provideRouteAlternatives: false
      };
      directionsService.route(request, (result, status) => {
        if (status === 'OK') {
          directionsRendererTemp.setMap(map);
          directionsRendererTemp.setDirections(result);
          try {
            const bounds = new google.maps.LatLngBounds();
            bounds.extend(result.routes[0].legs[0].start_location);
            bounds.extend(result.routes[0].legs[0].end_location);
            map.fitBounds(bounds);
          } catch(e){}
          renderTempDetails(result, poi);
        } else {
          showToast('Erro ao calcular rota temporária: ' + status, true);
        }
      });
    }

    function renderTempDetails(routeResult, poi) {
      const container = document.getElementById('route-details');
      let html = '<h3 class="font-semibold mb-2">Detalhes do Percurso:</h3>';
      if (lastRouteResult && lastRouteResult.routes) {
        html += '<div class="text-sm text-gray-600 mb-2">Rota principal (salva)</div>';
      }
      try {
        const leg = routeResult.routes[0].legs[0];
        html += `
          <div class="bg-green-50 p-3 rounded-lg mb-2">
            <div class="flex justify-between items-center">
              <div>
                <p class="font-medium">Rota temporária → ${escapeHtml(poi.name)}</p>
                <p class="text-sm text-gray-600">${escapeHtml(leg.distance.text)} • ${escapeHtml(leg.duration.text)}</p>
              </div>
              <p class="text-travel-700 font-medium">${escapeHtml(leg.duration.text)}</p>
            </div>
            <div class="mt-2 text-xs text-gray-600">Se desejar, clique em <strong>Desistir</strong> para voltar à rota original.</div>
          </div>
        `;
      } catch (e) { console.warn(e); }
      container.innerHTML = html;
    }

    function abortTemporaryRoute() {
      tempDestination = null;
      directionsRendererTemp.setMap(null);
      document.getElementById('abort-temp').style.display = 'none';
      showToast('Voltando à rota original.');
      if (lastRouteResultSaved) {
        try {
          lastRouteResult = JSON.parse(JSON.stringify(lastRouteResultSaved));
          directionsRendererMain.setMap(map);
          directionsRendererMain.setDirections(lastRouteResult);
          renderRouteDetails(lastRouteResult);
          updateStats();
        } catch (e) {
          document.getElementById('route-details').innerHTML = '';
        }
      } else {
        document.getElementById('route-details').innerHTML = '';
      }
    }

    // ---------- Listeners, botões e interações ----------
    function setupEventListeners() {
      document.getElementById('add-place').addEventListener('click', () => {
        const name = document.getElementById('place-name').value.trim();
        const value = parseFloat(document.getElementById('place-value').value) || 0;
        const category = document.getElementById('place-category').value;
        if (!name) { showToast('Por favor, digite um nome para o local', true); return; }
        if (!map) { showToast('Mapa ainda não carregado. Aguarde.', true); return; }
        const center = map.getCenter();
        const newPlace = {
          name, value, category,
          lat: center ? center.lat() : -15.795,
          lng: center ? center.lng() : -47.891,
          address: document.getElementById('search').value || '',
          date: new Date().toISOString()
        };
        places.push(newPlace); saveData(); renderPlaces(); updateRoute(); showToast('Local adicionado com sucesso!');
        document.getElementById('place-name').value = ''; document.getElementById('place-value').value = ''; document.getElementById('search').value = '';
      });

      document.getElementById('btn-search').addEventListener('click', () => {
        const query = document.getElementById('search').value.trim();
        if (!query) { showToast('Digite algo para pesquisar.', true); return; }
        if (!map || !google || !google.maps || !google.maps.places) { showToast('Serviço de lugares não disponível no momento.', true); return; }
        searchPlaceQuery(query);
      });

      document.getElementById('add-expense').addEventListener('click', () => {
        const title = document.getElementById('expense-title').value.trim();
        const amount = parseFloat(document.getElementById('expense-amount').value);
        if (!title || isNaN(amount)) { showToast('Por favor, preencha todos os campos do gasto', true); return; }
        generalExpenses.push({ title, amount, date: new Date().toISOString() });
        saveData(); renderExpenses(); showToast('Gasto adicionado com sucesso!');
        document.getElementById('expense-title').value = ''; document.getElementById('expense-amount').value = '';
      });

      document.getElementById('places-list').addEventListener('click', (e) => {
        const btn = e.target.closest('button'); if (!btn) return;
        const index = parseInt(btn.dataset.index); if (isNaN(index)) return;
        if (btn.classList.contains('delete-place')) {
          if (confirm('Remover este local?')) { places.splice(index,1); saveData(); renderPlaces(); updateRoute(); showToast('Local removido!'); }
        } else if (btn.classList.contains('move-up') && index > 0) {
          [places[index-1], places[index]] = [places[index], places[index-1]]; saveData(); renderPlaces(); updateRoute();
        } else if (btn.classList.contains('move-down') && index < places.length-1) {
          [places[index+1], places[index]] = [places[index], places[index+1]]; saveData(); renderPlaces(); updateRoute();
        }
      });

      document.getElementById('expenses-list').addEventListener('click', (e) => {
        const btn = e.target.closest('button'); if (!btn) return;
        const index = parseInt(btn.dataset.index); if (isNaN(index)) return;
        if (confirm('Remover este gasto?')) { generalExpenses.splice(index,1); saveData(); renderExpenses(); showToast('Gasto removido!'); }
      });

      document.getElementById('optimize-route').addEventListener('click', () => {
        if (places.length < 2) { showToast('Adicione pelo menos 2 locais para otimizar a rota', true); return; }
        updateRoute(); showToast('Rota otimizada com sucesso!');
      });

      document.getElementById('clear-route').addEventListener('click', () => {
        if (places.length > 0 && confirm('Tem certeza que deseja limpar toda a rota?')) {
          places = []; generalExpenses = []; saveData(); renderPlaces(); renderExpenses(); updateRoute();
          stopGPSTracking();
          if (currentPositionMarker) { currentPositionMarker.setMap(null); currentPositionMarker=null; }
          if (pathPolyline) { pathPolyline.setMap(null); }
          pathCoordinates = [];
          poiMarkers.forEach(m=>m.setMap(null)); poiMarkers=[];
          directionsRendererTemp.setMap(null);
          tempDestination = null;
          document.getElementById('abort-temp').style.display = 'none';
          showToast('Roteiro limpo com sucesso!');
        }
      });

      document.getElementById('start-trip').addEventListener('click', () => {
        if (watchId) { stopGPSTracking(); showToast('Rastreamento parado'); }
        else { startGPSTracking(); }
      });

      document.getElementById('fuel-efficiency').addEventListener('change', updateStats);
      document.getElementById('fuel-price').addEventListener('change', updateStats);

      document.getElementById('search').addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); document.getElementById('btn-search').click(); } });

      document.getElementById('abort-temp').addEventListener('click', () => { if (confirm('Deseja abandonar o destino temporário e voltar à rota original?')) abortTemporaryRoute(); });

      // toggles follow mode on map click + ctrl
      map && map.addListener && map.addListener('click', (e) => {
        // switch follow mode when user manually moves map (if implemented)
      });

      // permitir toque rápido em indicador "Seguindo" para travar/destrav
      const followInd = document.getElementById('follow-ind');
      followInd && followInd.addEventListener && followInd.addEventListener('click', () => {
        followMode = !followMode;
        followInd.textContent = followMode ? 'Seguindo' : 'Não seguindo';
        showToast(followMode ? 'Seguindo posição' : 'Parado (mapa livre)');
      });
    }

    // ---------- carregar Google Maps script dinamicamente ----------
    function loadGoogleMaps() {
      if (!GM_API_KEY || GM_API_KEY === 'YOUR_API_KEY_HERE') {
        console.warn('Substitua YOUR_API_KEY_HERE pela sua chave do Google Maps.');
      }
      const script = document.createElement('script');
      script.src = `https://maps.googleapis.com/maps/api/js?key=$AIzaSyAPkjcgFgdopkeZN0GnvhOc787jrajJnWc&libraries=places,directions,geometry&callback=initMap`;
      script.async = true;
      script.defer = true;
      script.onerror = () => showToast('Falha ao carregar Google Maps. Verifique sua chave/API.', true);
      document.head.appendChild(script);
    }

    // inicializa
    window.addEventListener('DOMContentLoaded', loadGoogleMaps);

    /* ---------------------------------------------------------------
       FIM DO SCRIPT PRINCIPAL
       --------------------------------------------------------------- */

    /*
      Observações / dicas:
      - Troque a variável GM_API_KEY pelo seu token válido (Places, Directions, Maps).
      - Eu implementei:
         * marcadores de locais salvos com ícones em azul claro (savedPlaceIconUrl).
         * busca via "Pesquisar" que cria um marcador temporário azul claro com peng visual,
           arrastável para ajustar a posição exata e botão "Salvar neste local".
         * quando clica em POIs dos resultados automáticos, há botão "Ir até aqui" (rota temporária)
           e "Salvar" para adicionar rapidamente no local original.
         * rastreamento GPS com suavização (média móvel curta) e threshold de movimento para evitar jitter.
      - Não mexi na estrutura geral do HTML (mantive sua organização de cards), apenas acrescentei código
        JS/CSS para implementar as correções que você pediu.
    */

  </script>
</body>
</html>
